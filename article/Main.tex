\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{breakurl}
\usepackage[utf8]{inputenc}
\usepackage[titletoc,toc,title]{appendix}

% listings
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.95,0.95,0.95}
\lstset{
backgroundcolor=\color{lbcolor},
    tabsize=4,    
%   rulecolor=,
    language=C,
        basicstyle=\scriptsize,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}’.
}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{OliveGreen},
  stringstyle=\color{red}
  }

\title{Comparation of execution time sort algorithms implementations in C\\
Counting sort and Bucket sort}
\author{
	  Pelczar Piotr\\
	  \small{\texttt{piotpel817@student.polsl.pl}}
	}
\usepackage{datetime}
\newdate{date}{08}{03}{2014}
\date{\displaydate{date}}
 
\begin{document}
\maketitle
 
\begin{abstract}
This paper describes and compares counting sort and bucket sort algorithms implementations written in C language.
The main doubt is what is the impact of pointers operations in \emph{bucket sort} relatively to single operations on arrays
in \emph{counting sort}.
\end{abstract}

\renewcommand{\contentsname}{Contents}

\newpage
\tableofcontents

\newpage
\section{Introduction}
\label{sec:intro}

This paper describes computational complexity comparation of two sorting algorithms based on indexing keys: \emph{bucket sort} and \emph{counting sort}. This is specific class of algorithms, which implicts some constraints on sorting keys. Keys are indicies of arrays in implemetations so in special cases the key have to be positive whole number between 0 and max integer range (0..65536) depends on platform. Both algorithms have simmilar linear computational complexity.

Bucket sort creates array of one-way list of elements (a.k.a. \emph{buckets}), which is merged at the end. This behaviour requires pointer operations\cite{cormen}.

Counting sort creates an array that represents counts of keys, and next the prefix-sum is defined, which describes how many lower keys there are before each key\cite{cormen}. That allows to simply insert keys in proper place. Algorithm is stable\footnote{Positions of items are not relatively changed after algorithm iteration.}.

Both of algoritmhs has been implemented in C language.

\section{Implementation}
\subsection{Bucket sort}

Based on pseudocode\cite{czech}.

\lstinputlisting[language=C]{../code/sort_algorithms/bucket_sort.c}

\subsection{Counting sort}

Based on pseudocode\cite{czech}.

\lstinputlisting[language=C]{../code/sort_algorithms/counting_sort.c}

\section{Comparation}

\subsection{Methodology}

Codes has been compiled in gcc 4.2.1 compiler under MacOSX in 3 optimization modes (0 - none, 1, 2 and 3)\cite{man-gcc}.

\begin{lstlisting}
$ gcc -v
gcc version 4.2.1 (Apple Inc. build 5664)
\end{lstlisting}

Compilation process has been automated by Bash script listed in Appendix \ref{app:compilation}:

\begin{lstlisting}
$ ./bin/compile-all-optimizations.sh
\end{lstlisting}

The dataset is generated by script listed in Appendix \ref{app:dataset}. \emph{n} numbers (keys) are generated from range \emph{min} to \emph{max} which determines range of keys.

\begin{lstlisting}
$ ./bin/rand-dataset.sh min max n
\end{lstlisting}

The algorithms are invoked by benchmark program listed in Appendix \ref{app:benchmark} in \emph{n} iterations. Memory allocations are not measured, time counters are aware only for sorting operations.

\subsection{Hardware}

Benchmark has been done on MacBook Pro with 2.4GHz Intel with single phisical dual core processor:

\lstinputlisting[language=C]{./materials/computer-info.txt}

\subsection{Results}

\section{Conclusion}

\begin{appendices}
	\section{Dataset generation script}
	\label{app:dataset}

	\lstinputlisting[language=Bash]{../bin/rand-dataset.sh}
	
	\section{Benchmark program}
	\label{app:benchmark}

	\lstinputlisting[language=C]{../code/benchmark.c}
	
	\section{Compilation script}
	\label{app:compilation}

	\lstinputlisting[language=Bash]{../bin/compile-all-optimizations.sh}

\end{appendices}

\begin{thebibliography}{9}

\bibitem{cormen}
  Thomas H. Cormen,
  \emph{Introduction To Algorithms}.
  The MIT Press,
  2nd Edition,
  2003.

\bibitem{czech}
  Zbigniew J. Czech,
  \emph{Algorytmy i struktury danych - Materiały dydaktyczne}.
  Politechnika Slaska, Instytut Informatyki,
  2011.
  ftp://sun.aei.polsl.pl/pub/zjc/asd.pdf [\emph{Retreived on 2013-03-08}]

\bibitem{man-gcc}
  gcc manual,
  http://linux.die.net/man/1/gcc

\end{thebibliography}
 
\end{document}